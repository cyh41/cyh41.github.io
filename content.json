{"meta":{"title":"south-park","subtitle":null,"description":"screw you guys I'm going home","author":"cyh41","url":"https://cyh41.github.io","root":"/"},"pages":[{"title":"Tags","date":"2019-03-22T16:05:04.000Z","updated":"2019-03-22T16:25:09.997Z","comments":true,"path":"tags/index.html","permalink":"https://cyh41.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2019-03-22T15:58:29.000Z","updated":"2019-03-22T16:25:06.029Z","comments":true,"path":"categories/index.html","permalink":"https://cyh41.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"vue-双向绑定与事件(上)","slug":"vue-双向绑定与事件(上)","date":"2019-09-17T09:47:58.000Z","updated":"2019-09-21T02:20:29.190Z","comments":true,"path":"2019/09/17/vue-双向绑定与事件(上)/","link":"","permalink":"https://cyh41.github.io/2019/09/17/vue-双向绑定与事件(上)/","excerpt":"","text":"Preface1.vue的双向绑定是什么❓2.v-model的原理是什么❓3.为什么v-model只适用于表单元素❓4.为何你这么捞❓ What’s the v-model 普通表单元素使用 v-model 12345678910111213141516171819202122232425262728&lt;!-- v-model.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;input v-model=\"text\"&gt; &lt;!-- 这里的值会跟input的值同步 --&gt; &lt;p&gt;&#123;&#123;text&#125;&#125;&lt;/p&gt; &lt;input type=\"checkbox\" v-model=\"checked\"&gt; &lt;!-- 这里的值会跟checkbox的值同步 --&gt; &lt;p&gt;&#123;&#123;checked&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"v-model\", data() &#123; return &#123; text: \"\", checked:false &#125;; &#125;&#125;;&lt;/script&gt; 等同于 123456789101112131415161718192021222324252627282930&lt;!-- v-model.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;input :value=\"text\" @input=\"this.text = $event.target.value\"&gt; &lt;!-- 这里的值会跟input输入的值同步 --&gt; &lt;p&gt;&#123;&#123;text&#125;&#125;&lt;/p&gt; &lt;input type=\"checkbox\" :checked=\"checked\" @change=\"checked = $event.target.checked\"&gt; &lt;!-- 这里的值会跟checkbox的值同步 --&gt; &lt;p&gt;&#123;&#123;checked&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"v-model\", data() &#123; return &#123; text: \"\", checked:false &#125;; &#125;&#125;;&lt;/script&gt; 简单来说 v-model就是 prop + event 的语法🍬。针对不同的表单类型，vue都会有一套不同的默认 mode 。 text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 这里 也很好的回答了前言的第3个问题。为什么v-model只适用于表单元素? 因为只有表单元素会有默认的event，当然也可以自定义指令去解决。不过其它元素本身就有一些不错的类似于 v-model的方案。 组件使用 v-model 1234567891011121314151617&lt;!--el-input.vue --&gt;&lt;template&gt; &lt;input :value=\"value\" @input=\"$emit('input',$event.target.value)\" /&gt; &lt;/template&gt;&lt;script&gt;export default &#123; name:'el-input', //这里其实默认配置了model // model: &#123; // props: \"value\", // event: \"input\" // &#125;, props:['value']&#125;&lt;/script&gt; 1234567891011121314151617181920&lt;!--el-checkbox.vue --&gt;&lt;template&gt; &lt;input type=\"checkbox\" :checked=\"checked\" @change=\"$emit('change',$event.target.checked)\" /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:'el-checkbox', //这里需要手动声明model model: &#123; props: \"checked\", event: \"change\" &#125;, props:['checked']&#125;&lt;/script&gt; 123456789101112131415161718192021222324252627&lt;!--box.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;el-input v-model=\"value\" /&gt; &lt;!--等同于 &lt;el-input :value=\"value\" @input=\"value=$event.target.value\"/&gt;--&gt; &lt;el-checkbox v-model=\"checked\"&gt;&lt;/el-checkbox&gt; &lt;!--等同于 &lt;el-input :checked=\"checked\" @change=\"value=$event.target.checked\"/&gt;--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:'box', data()&#123; return &#123; //el-input绑定的值 value:'', //el-checkbox绑定的值 checked:false &#125;&#125;&#125;&lt;/script&gt; 通过上面的🌰，其实可以很直观的看到，v-model 所谓的双向绑定，同样也只是个语法🍬而已，单向绑定value + 事件侦听。其实操作的都只是同一个value。 在使用 v-model 进行上面操作的时候有几个地方需要注意⚠️： v-model 仅仅适用于表单元素 12345678910111213141516&lt;!--el-input.vue --&gt; &lt;template&gt; &lt;!--v-model被传递到了根元素div上，此时input的操作都无效了 --&gt; &lt;div&gt; &lt;input :value=\"value\" @input=\"$emit('input',$event.target.value)\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;!--box.vue--&gt;&lt;template&gt; &lt;div&gt; &lt;!--这里会把v-model传递到el-input的根元素上 --&gt; &lt;el-input v-model=\"value\"&gt;&lt;/el-input&gt; &lt;/div&gt;&lt;/template&gt; 子组件中不能使用 v-model 绑定父组件传递的prop的值 123456789101112&lt;!--el-input.vue --&gt; &lt;template&gt; &lt;!--这里没有使用语法糖v-model &lt;input :value=\"value\" @input=\"$emit('input',$event.target.value)\" /&gt;--&gt; &lt;!--如果使用v-model --&gt; &lt;input v-model=\"value\"/&gt; &lt;!--等同于 &lt;input :value=\"value\" @input=\"value=$event.target.value\" /&gt;--&gt;&lt;/template&gt; 如果这么写会直接⚠️ 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。","categories":[{"name":"front-end","slug":"front-end","permalink":"https://cyh41.github.io/categories/front-end/"}],"tags":[{"name":"What's up Vue","slug":"What-s-up-Vue","permalink":"https://cyh41.github.io/tags/What-s-up-Vue/"},{"name":"component communication","slug":"component-communication","permalink":"https://cyh41.github.io/tags/component-communication/"}]},{"title":"vue-$attrs","slug":"vue-$attrs","date":"2019-08-23T08:24:06.000Z","updated":"2019-09-20T07:33:34.856Z","comments":true,"path":"2019/08/23/vue-$attrs/","link":"","permalink":"https://cyh41.github.io/2019/08/23/vue-$attrs/","excerpt":"","text":"Preface在我们日常通信中，prop，基本可以满足业务场景中父子通信的情况。但在高级组件中，比如自己写的通用组件，二次封装element等UI框架等场景，attrs和listeners就大有作为了。 Basics Code 1234567&lt;!-- China.vue --&gt;&lt;template&gt; &lt;div class=\"China\"&gt; &lt;HongKong where=\"China\" :money=\"100\"/&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718&lt;!-- HongKong.vue --&gt;&lt;template&gt; &lt;div class=\"HongKong\"&gt; &lt;p&gt; Hongkong is part of &#123;&#123;where&#125;&#125; &lt;/p&gt; &lt;p&gt; show me the money:&#123;&#123;money&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"HongKong\", props: [\"where\"]&#125;;&lt;/script&gt; devTools Rendering 图中 Mustache语法money未在实例中找到该属性的声明，会报Property or method &quot;money&quot; is not defined on the instance but referenced during render错误。请确定声明后再使用。 可以看到，父组件 传递的属性未在 子组件props中声明，则会默认挂载至子组件根元素上。 这是因为：未在子组件props中声明的属性，会被作为普通的HTML特性应用在子组件的根元素上。可以通过配置子组件inheritAttrs:false（2.4.0 新增）将默认行为去掉（即，在根元素中不会挂载继承属性）。但无论是否配置inheritAttrs，都可以通实例属性$attrs（2.4.0 新增）获取到。 该属性不影响class和style。 1234//HongKongcreated()&#123; console.log(this.$attrs)//&#123;money:100&#125;&#125; Scene当我们自行封装一个简易的input组件，在使用过程中，可能传入不同的多个原生属性。 传统props写法： 1234567891011121314151617181920212223242526272829&lt;!-- box.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;label :for=\"name\"&gt;&#123;&#123;label&#125;&#125;&lt;/label&gt; &lt;el-input :type=\"type\" :value=\"value\" :name=\"name\" :placeholder=\"placeholder\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ElInput from \"@/components/input.vue\";export default &#123; components: &#123; ElInput &#125;, data() &#123; return &#123; label: \"姓名\", //要传入组件的属性 name: \"name\", type: \"text\", value: \"妮可基德曼\", placeholder: \"请输入姓名\" &#125;; &#125;&#125;;&lt;/script&gt; 1234567891011121314151617181920212223&lt;template&gt; &lt;div clas=\"el-input\"&gt; &lt;input class=\"input\" :type=\"type\" :value=\"value\" :name=\"name\" :placeholder=\"placeholder\" @input=\"handleInput\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ElInput\", props: [\"name\", \"type\", \"value\", \"placeholder\"], methods: &#123; handleInput(event) &#123; this.$emit(\"input\", event.target.value); &#125; &#125;&#125;;&lt;/script&gt; $attrs方法 123456789101112131415161718192021222324252627282930&lt;!-- box.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;label :for=\"inputConfig.name\"&gt;&#123;&#123;label&#125;&#125;&lt;/label&gt; &lt;el-input v-bind=\"inputConfig\" v-model=\"value\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ElInput from \"@/components/input.vue\";export default &#123; components: &#123; ElInput &#125;, data() &#123; return &#123; label: \"姓名\", value: \"nas\", inputConfig: &#123; //要传入组件的属性 name: \"name\", type: \"text\", placeholder: \"请输入姓名\" &#125; &#125;; &#125;&#125;;&lt;/script&gt; 123456789101112131415161718192021&lt;!-- input.vue --&gt;&lt;template&gt; &lt;div clas=\"el-input\"&gt; &lt;input class=\"input\" v-bind=\"$attrs\" @input=\"handleInput\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ElInput\", inheritAttrs: false,//不加这条规则，$attrs会默认挂载到根元素上 methods: &#123; handleInput(event) &#123; this.$emit(\"input\", event.target.value); &#125; &#125;&#125;;&lt;/script&gt; 很明显的，$attrs减少了不少的代码量，整体看起来确实优雅很多，虽说$attrs可以代替props，但$attrs更适合原生属性或不需要处理的属性。 在很多场景下，比如要对属性进行校验、默认值、处理等操作，更建议使用props。每个属性都有它存在的意义，合理的运用不同属性应对不同的场景，才能发挥其最大作用。 Others Lifecycle $attrs可访问的阶段是 beforeCreate，而props访问阶段为created。 Render Function &amp; JSX 12345678910111213141516//input.jsexport default &#123; name: 'ElInput', inheritAttrs: false, render(h) &#123; //TODO:这里放jsx或render function &#125;, methods: &#123; handleInput(event) &#123; this.$emit('input', event.target.value); &#125;, &#125;,&#125;; 123456789101112131415//render写法 render(h) &#123; return h('div', &#123; class: 'el-input', &#125;, [ h('input', &#123; //绑定在attrs上 attrs: this.$attrs, on: &#123; input: this.handleInput, &#125;, &#125;), ]); &#125;, 123456//jsx写法 render(h) &#123; return &lt;div class=\"el-input\"&gt; &lt;input attrs=&#123;this.$attrs&#125; on-input=&#123;this.handleInput&#125; /&gt; &lt;/div&gt;; &#125;, 若 v-bind=“$attrs” 中的某个属性 已经有声明，则原生属性的优先级更高。 12&lt;!-- $attrs为&#123;type:\"text\"&#125;，最后生效的为type=\"number\" --&gt;&lt;input type=\"number\" v-bind=\"$attrs\"/&gt;","categories":[{"name":"front-end","slug":"front-end","permalink":"https://cyh41.github.io/categories/front-end/"}],"tags":[{"name":"What's up Vue","slug":"What-s-up-Vue","permalink":"https://cyh41.github.io/tags/What-s-up-Vue/"},{"name":"component communication","slug":"component-communication","permalink":"https://cyh41.github.io/tags/component-communication/"}]}]}