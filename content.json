{"meta":{"title":"south-park","subtitle":null,"description":"screw you guys I'm going home","author":"cyh41","url":"https://cyh41.github.io","root":"/"},"pages":[{"title":"Categories","date":"2019-03-22T15:58:29.000Z","updated":"2019-03-22T16:25:06.029Z","comments":true,"path":"categories/index.html","permalink":"https://cyh41.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-03-22T16:05:04.000Z","updated":"2019-03-22T16:25:09.997Z","comments":true,"path":"tags/index.html","permalink":"https://cyh41.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"$attrs","date":"2019-08-22T01:53:59.803Z","updated":"2019-08-23T08:13:59.490Z","comments":true,"path":"2019/08/22/$attrs/","link":"","permalink":"https://cyh41.github.io/2019/08/22/$attrs/","excerpt":"","text":"Preface在我们日常通信中，prop，基本可以满足业务场景中父子通信的情况。但在高级组件中，比如自己写的通用组件，二次封装element等UI框架等场景，attrs和listeners就大有作为了。 Basics Code 1234567&lt;!-- China.vue --&gt;&lt;template&gt; &lt;div class=\"China\"&gt; &lt;HongKong where=\"China\" :money=\"100\"/&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718&lt;!-- HongKong.vue --&gt;&lt;template&gt; &lt;div class=\"HongKong\"&gt; &lt;p&gt; Hongkong is part of &#123;&#123;where&#125;&#125; &lt;/p&gt; &lt;p&gt; show me the money:&#123;&#123;money&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"HongKong\", props: [\"where\"]&#125;;&lt;/script&gt; devTools Rendering 图中 Mustache语法money未在实例中找到该属性的声明，会报Property or method &quot;money&quot; is not defined on the instance but referenced during render错误。请确定声明后再使用。 可以看到，父组件 传递的属性未在 子组件props中声明，则会默认挂载至子组件根元素上。 这是因为：未在子组件props中声明的属性，会被作为普通的HTML特性应用在子组件的根元素上。可以通过配置子组件inheritAttrs:false（2.4.0 新增）将默认行为去掉（即，在根元素中不会挂载继承属性）。但无论是否配置inheritAttrs，都可以通实例属性$attrs（2.4.0 新增）获取到。 该属性不影响class和style。 1234//HongKongcreated()&#123; console.log(this.$attrs)//&#123;money:100&#125;&#125; Scene当我们自行封装一个简易的input组件，在使用过程中，可能传入不同的多个原生属性。 传统props写法： 1234567891011121314151617181920212223242526272829&lt;!-- box.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;label :for=\"name\"&gt;&#123;&#123;label&#125;&#125;&lt;/label&gt; &lt;el-input :type=\"type\" :value=\"value\" :name=\"name\" :placeholder=\"placeholder\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ElInput from \"@/components/input.vue\";export default &#123; components: &#123; ElInput &#125;, data() &#123; return &#123; label: \"姓名\", //要传入组件的属性 name: \"name\", type: \"text\", value: \"妮可基德曼\", placeholder: \"请输入姓名\" &#125;; &#125;&#125;;&lt;/script&gt; 1234567891011121314151617181920212223&lt;template&gt; &lt;div clas=\"el-input\"&gt; &lt;input class=\"input\" :type=\"type\" :value=\"value\" :name=\"name\" :placeholder=\"placeholder\" @input=\"handleInput\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ElInput\", props: [\"name\", \"type\", \"value\", \"placeholder\"], methods: &#123; handleInput(event) &#123; this.$emit(\"input\", event.target.value); &#125; &#125;&#125;;&lt;/script&gt; $attrs方法 123456789101112131415161718192021222324252627282930&lt;!-- box.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;label :for=\"inputConfig.name\"&gt;&#123;&#123;label&#125;&#125;&lt;/label&gt; &lt;el-input v-bind=\"inputConfig\" v-model=\"value\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ElInput from \"@/components/input.vue\";export default &#123; components: &#123; ElInput &#125;, data() &#123; return &#123; label: \"姓名\", value: \"nas\", inputConfig: &#123; //要传入组件的属性 name: \"name\", type: \"text\", placeholder: \"请输入姓名\" &#125; &#125;; &#125;&#125;;&lt;/script&gt; 123456789101112131415161718192021&lt;!-- input.vue --&gt;&lt;template&gt; &lt;div clas=\"el-input\"&gt; &lt;input class=\"input\" v-bind=\"$attrs\" @input=\"handleInput\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ElInput\", inheritAttrs: false,//不加这条规则，$attrs会默认挂载到根元素上 methods: &#123; handleInput(event) &#123; this.$emit(\"input\", event.target.value); &#125; &#125;&#125;;&lt;/script&gt; 很明显的，$attrs减少了不少的代码量，整体看起来确实优雅很多，虽说$attrs可以代替props，但$attrs更适合原生属性或不需要处理的属性。 在很多场景下，比如要对属性进行校验、默认值、处理等操作，更建议使用props。每个属性都有它存在的意义，合理的运用不同属性应对不同的场景，才能发挥其最大作用。 Others Lifecycle $attrs可访问的阶段是 beforeCreate，而props访问阶段为created。 Render Function &amp; JSX 12345678910111213141516//input.jsexport default &#123; name: 'ElInput', inheritAttrs: false, render(h) &#123; //TODO:这里放jsx或render function &#125;, methods: &#123; handleInput(event) &#123; this.$emit('input', event.target.value); &#125;, &#125;,&#125;; 123456789101112131415//render写法 render(h) &#123; return h('div', &#123; class: 'el-input', &#125;, [ h('input', &#123; //绑定在attrs上 attrs: this.$attrs, on: &#123; input: this.handleInput, &#125;, &#125;), ]); &#125;, 123456//jsx写法 render(h) &#123; return &lt;div class=\"el-input\"&gt; &lt;input attrs=&#123;this.$attrs&#125; on-input=&#123;this.handleInput&#125; /&gt; &lt;/div&gt;; &#125;, 若 v-bind=“$attrs” 中的某个属性 已经有声明，则原生属性的优先级更高。 12&lt;!-- $attrs为&#123;type:\"text\"&#125;，最后生效的为type=\"number\" --&gt;&lt;input type=\"number\" v-bind=\"$attrs\"/&gt;","categories":[],"tags":[]}]}