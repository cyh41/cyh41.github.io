{"meta":{"title":"south-park","subtitle":null,"description":"screw you guys I'm going home","author":"cyh41","url":"https://cyh41.github.io","root":"/"},"pages":[{"title":"Tags","date":"2019-03-22T16:05:04.000Z","updated":"2019-03-22T16:25:09.997Z","comments":true,"path":"tags/index.html","permalink":"https://cyh41.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2019-03-22T15:58:29.000Z","updated":"2019-03-22T16:25:06.029Z","comments":true,"path":"categories/index.html","permalink":"https://cyh41.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"$attrs","date":"2019-08-22T01:53:59.803Z","updated":"2019-08-23T08:13:59.490Z","comments":true,"path":"2019/08/22/$attrs/","link":"","permalink":"https://cyh41.github.io/2019/08/22/$attrs/","excerpt":"","text":"Preface 在我们日常通信中，prop，基本可以满足业务场景中父子通信的情况。但在高级组件中，比如自己写的通用组件，二次封装element等UI框架等场景，attrs和listeners就大有作为了。 Basics Code 1234567&lt;!-- China.vue --&gt;&lt;template&gt; &lt;div class=\"China\"&gt; &lt;HongKong where=\"China\" :money=\"100\"/&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718&lt;!-- HongKong.vue --&gt;&lt;template&gt; &lt;div class=\"HongKong\"&gt; &lt;p&gt; Hongkong is part of &#123;&#123;where&#125;&#125; &lt;/p&gt; &lt;p&gt; show me the money:&#123;&#123;money&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"HongKong\", props: [\"where\"]&#125;;&lt;/script&gt; devTools Rendering 图中 Mustache语法money未在实例中找到该属性的声明，会报Property or method &quot;money&quot; is not defined on the instance but referenced during render错误。请确定声明后再使用。 可以看到，父组件 传递的属性未在 子组件props中声明，则会默认挂载至子组件根元素上。 这是因为：未在子组件props中声明的属性，会被作为普通的HTML特性应用在子组件的根元素上。可以通过配置子组件inheritAttrs:false（2.4.0 新增）将默认行为去掉（即，在根元素中不会挂载继承属性）。但无论是否配置inheritAttrs，都可以通实例属性$attrs（2.4.0 新增）获取到。 该属性不影响class和style。 1234//HongKongcreated()&#123; console.log(this.$attrs)//&#123;money:100&#125;&#125; Scene 当我们自行封装一个简易的input组件，在使用过程中，可能传入不同的多个原生属性。 传统props写法： 1234567891011121314151617181920212223242526272829&lt;!-- box.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;label :for=\"name\"&gt;&#123;&#123;label&#125;&#125;&lt;/label&gt; &lt;el-input :type=\"type\" :value=\"value\" :name=\"name\" :placeholder=\"placeholder\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ElInput from \"@/components/input.vue\";export default &#123; components: &#123; ElInput &#125;, data() &#123; return &#123; label: \"姓名\", //要传入组件的属性 name: \"name\", type: \"text\", value: \"妮可基德曼\", placeholder: \"请输入姓名\" &#125;; &#125;&#125;;&lt;/script&gt; 1234567891011121314151617181920212223&lt;template&gt; &lt;div clas=\"el-input\"&gt; &lt;input class=\"input\" :type=\"type\" :value=\"value\" :name=\"name\" :placeholder=\"placeholder\" @input=\"handleInput\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ElInput\", props: [\"name\", \"type\", \"value\", \"placeholder\"], methods: &#123; handleInput(event) &#123; this.$emit(\"input\", event.target.value); &#125; &#125;&#125;;&lt;/script&gt; $attrs方法 123456789101112131415161718192021222324252627282930&lt;!-- box.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;label :for=\"inputConfig.name\"&gt;&#123;&#123;label&#125;&#125;&lt;/label&gt; &lt;el-input v-bind=\"inputConfig\" v-model=\"value\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ElInput from \"@/components/input.vue\";export default &#123; components: &#123; ElInput &#125;, data() &#123; return &#123; label: \"姓名\", value: \"nas\", inputConfig: &#123; //要传入组件的属性 name: \"name\", type: \"text\", placeholder: \"请输入姓名\" &#125; &#125;; &#125;&#125;;&lt;/script&gt; 123456789101112131415161718192021&lt;!-- input.vue --&gt;&lt;template&gt; &lt;div clas=\"el-input\"&gt; &lt;input class=\"input\" v-bind=\"$attrs\" @input=\"handleInput\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ElInput\", inheritAttrs: false,//不加这条规则，$attrs会默认挂载到根元素上 methods: &#123; handleInput(event) &#123; this.$emit(\"input\", event.target.value); &#125; &#125;&#125;;&lt;/script&gt; 很明显的，$attrs减少了不少的代码量，整体看起来确实优雅很多，虽说$attrs可以代替props，但$attrs更适合原生属性或不需要处理的属性。 在很多场景下，比如要对属性进行校验、默认值、处理等操作，更建议使用props。每个属性都有它存在的意义，合理的运用不同属性应对不同的场景，才能发挥其最大作用。 Others Lifecycle $attrs可访问的阶段是 beforeCreate，而props访问阶段为created。 Render Function &amp; JSX 12345678910111213141516//input.jsexport default &#123; name: 'ElInput', inheritAttrs: false, render(h) &#123; //TODO:这里放jsx或render function &#125;, methods: &#123; handleInput(event) &#123; this.$emit('input', event.target.value); &#125;, &#125;,&#125;; 123456789101112131415//render写法 render(h) &#123; return h('div', &#123; class: 'el-input', &#125;, [ h('input', &#123; //绑定在attrs上 attrs: this.$attrs, on: &#123; input: this.handleInput, &#125;, &#125;), ]); &#125;, 123456//jsx写法 render(h) &#123; return &lt;div class=\"el-input\"&gt; &lt;input attrs=&#123;this.$attrs&#125; on-input=&#123;this.handleInput&#125; /&gt; &lt;/div&gt;; &#125;, 若 v-bind=“$attrs” 中的某个属性 已经有声明，则原生属性的优先级更高。 12&lt;!-- $attrs为&#123;type:\"text\"&#125;，最后生效的为type=\"number\" --&gt;&lt;input type=\"number\" v-bind=\"$attrs\"/&gt;","categories":[],"tags":[]},{"title":"What's up Vue -属性-props","slug":"What-s-up-Vue-属性-props","date":"2019-04-23T11:11:51.000Z","updated":"2019-07-24T13:21:41.741Z","comments":true,"path":"2019/04/23/What-s-up-Vue-属性-props/","link":"","permalink":"https://cyh41.github.io/2019/04/23/What-s-up-Vue-属性-props/","excerpt":"","text":"preface 首先要非常明确的说明，Vue是单向数据流，不是双向绑定，所谓的双向绑定仅仅只是个语法糖而已。prop只是形成一个 单向下行绑定（父级prop的更新会向下流动到子组件中，但反过来则不行）。 如果需要将这个值作为本地的prop数据来使用。最好定义一个本地的data或computed来使用 123456props:['initialCounter'], data()&#123; return&#123; counter: this.initialCounter &#125;&#125; 123456props: ['size'],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 需要注意的是，JavaScript 中对象和数组是通过引用传入的 1234567891011121314/*initialObj = &#123;name:'shit'&#125;*/props: ['initialObj'], created()&#123; this.obj.name = 'asshole'//虽然修改的obj.name，但是initialObj.name同样会改变&#125;,data()&#123; return&#123; obj : this.initialObj &#125;&#125;","categories":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://cyh41.github.io/categories/frontEnd/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://cyh41.github.io/tags/vue/"}]},{"title":"What's up Vue -属性-attrs","slug":"What-s-up-Vue-属性-attrs","date":"2019-04-20T09:16:01.000Z","updated":"2019-07-23T11:52:13.015Z","comments":true,"path":"2019/04/20/What-s-up-Vue-属性-attrs/","link":"","permalink":"https://cyh41.github.io/2019/04/20/What-s-up-Vue-属性-attrs/","excerpt":"","text":"preface 在讲 attrs 之前，先简单介绍一下 组件的三大核心概念。 分别是：属性、事件、插槽。 这三大核心概念是vue组件的支撑，我会作为这个系列的第一个重点来讲，并且会在后面详细介绍。 这篇主要就是讲解一下 **属性 **中的 attrs。 文中代码基本上只展示关键部分 属性 首先 vue当中，属性分为了三类 自定义属性props，常用于父子组件之前的通信 原生属性attrs，属于 当子组件没有接收（props中没声明）其属性，则该属性会自动挂载到组件根元素上 特殊属性不多说了吧 Attrs（原生属性） inheritAttrs 默认情况下 父组件传递个属性给子组件 子组件中未在props中声明该属性，同时不设置 inheritAttrs到false 该属性则作为普通的 HTML 特性 应用在子组件的根元素上 话不多B，直接上code 父组件在 子组件上加了一个 自定义属性 text 123456789101112131415&lt;!--父组件--&gt;&lt;template&gt; &lt;!-- 子组件child-component --&gt; &lt;child-component text=\"inheritAttrs默认为true\" class=\"parent-class\" :style=\"&#123;color:'#000'&#125;\"&gt;&lt;/child-component&gt;&lt;/template&gt;&lt;script&gt;import ChildComponent from \"@/components/ChildComponent.vue\";export default &#123;name: \"parentComponent\",components: &#123; ChildComponent&#125;&#125;;&lt;/script&gt; 子组件内部没有用props声明该属性，同时inheritAttrs不为false。 1234567891011121314&lt;!--子组件--&gt;&lt;template&gt; &lt;div&gt; 我是子组件 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ChildComponent\" // inheritAttrs:true, // props:&#123;&#125;&#125;;&lt;/script&gt; 默认inheritAttrs，或inheritAttrs为true inheritAttrs为false，text属性不见了，class跟style依然挂载 虽然inheritAttrs:false阻止了 原生属性默认挂载在跟元素上的特性（非 class 和 style ），但是我们依然可以通过vm.$attrs 这个实例属性去访问到（访问不到class和style）。 1234567891011121314&lt;!--子组件--&gt;&lt;!--省略html--&gt;&lt;script&gt;export default &#123; name: \"childComponent\" inheritAttrs:false, // props:&#123;&#125; create()&#123; //可以直接访问得到所有的原生属性 console.log(this.$attrs) &#125;&#125;;&lt;/script&gt; 简单来说inheritAttrs:false可以避免通信的数据直接暴露在html上，而$attrs的妙用不仅仅如此 场景实例 有这么一个场景（父=&gt;子=&gt;孙的通信），你需要通过修改父组件的属性去更新孙组件。这里是需 要把input的类型改为 button。 123456&lt;!--父组件--&gt;&lt;!-- 子组件child-component --&gt; &lt;child-component type=\"button\"&gt;&lt;/child-component&gt;&lt;!--省略script--&gt; 1234567&lt;!--子组件--&gt;&lt;div&gt;&lt;!-- 孙组件grand-component --&gt; &lt;grand-component&gt;&lt;/grand-component&gt;&lt;/div&gt;&lt;!--省略script--&gt; 123&lt;!--孙组件 孙子孙女,whatever--&gt; &lt;input vlaue=\"我其实是一个按钮\"&gt;&lt;!--省略script--&gt; Props方法 层层传递法，每层用props接收。 12345678910111213&lt;!--子组件--&gt;&lt;!-- 传递type给孙组件 --&gt;&lt;grand-component :type=\"type\"&gt;&lt;/grand-component&gt; &lt;script&gt; export default &#123; props:&#123; //接收 父组件传递的属性type type:String &#125; &#125;; &lt;/script&gt; 12345678910111213&lt;!--孙组件--&gt;&lt;!-- 祖父传的type，经过重重传递，终于传过来了 --&gt;&lt;input :type=\"type\"&gt; &lt;script&gt; export default &#123; props:&#123; //接收 子组件（这里是父组件）接收父组件（这里是祖父组件）传递的type，是不是晕了？晕就对了，这才跨了一层，如果跨N层呢？ type:String &#125; &#125;; &lt;/script&gt; $attrs方法 只需在中间层配置 1234567891011&lt;!--子组件--&gt;&lt;!-- 将$attrs直接传递给孙组件，我甚至不需要知道$attrs里面有什么 --&gt;&lt;grand-component v-bind=\"$attrs\"&gt;&lt;/grand-component&gt; &lt;script&gt; export default &#123; inheritAttrs:false, //我不希望html里面有我的数据 //props:&#123;&#125; 不需要props了 &#125;; &lt;/script&gt; Ok，就这样了，孙组件不用改动，就可以直接生效。虽然说两种方法都能解决跨组件通信，但是明显 $attrs 代码量少、维护性更高。 $attrs这里有几个地方需要注意： 1.当孙组件中已经拥有了该属性，会被祖父传递的属性覆盖 2.class和style依然无效，不能通过此方法给孙子传递 3.不能将 v-bind=&quot;$attrs&quot;缩写为:$attrs 4.$attrs的应用场景不多，仅限于应用在子组件的根元素上","categories":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://cyh41.github.io/categories/frontEnd/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://cyh41.github.io/tags/vue/"}]}]}