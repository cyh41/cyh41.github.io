{"meta":{"title":"south-park","subtitle":null,"description":"screw you guys I'm going home","author":"cyh41","url":"https://cyh41.github.io","root":"/"},"pages":[{"title":"Categories","date":"2019-03-22T15:58:29.000Z","updated":"2019-03-22T16:25:06.029Z","comments":true,"path":"categories/index.html","permalink":"https://cyh41.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-03-22T16:05:04.000Z","updated":"2019-03-22T16:25:09.997Z","comments":true,"path":"tags/index.html","permalink":"https://cyh41.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"webpack-基础配置与多环境配置","slug":"webpack-基础配置与多环境配置","date":"2019-09-24T01:32:44.000Z","updated":"2019-09-25T08:41:27.692Z","comments":true,"path":"2019/09/24/webpack-基础配置与多环境配置/","link":"","permalink":"https://cyh41.github.io/2019/09/24/webpack-基础配置与多环境配置/","excerpt":"","text":"Prefacewebpack 是个 模块打包器。从配置的入口进入，找寻所有相关依赖。并将所有依赖打包成一个或多个 bundle。 webpack默认支持 common.js 规范和 es6 规范。 Install从4.0开始，需要同时安装 webpack-cli ，用来解析命令行后的参数。 只需在开发环境中安装使用 1yarn add webpack webpack-cli --save-dev 在package.json配置scripts既可使用。 以下，打包有两种方法，一种是 dev模式（基本用不到），一种是prod模式。webpack4.0的config会根据mode 判断当前命令是在开发环境执行还是生产环境。 1234\"scripts\":&#123; \"dev-build\": \"webpack --mode development\" \"build\": \"webpack --mode produciton\"&#125; 区分环境配置在开发过程中，为了更灵活的配置不同的环境，可以引入一个变量来区分不同的环境。并且通过 --config 设置需要访问的配置文件。 script中的命令，会找 node_modules 下的 .bin 目录进行执行。 12345\"scripts\":&#123; \"dev-build\": \"webpack --env.development --config ./build/webpack.base.js\", \"build\": \"webpack --env.produciton --config ./build/webpack.base.js\"&#125; 在根目录新建 build文件夹，内部新建 公共配置 webpack.base.js 开发环境 webpack.dev.js 生产环境 webpack.prod.js 12345678910111213141516171819/**webpack.base.js*///引入开发和生产的配置configconst dev = require('./webpack.dev');const prod = require('./webpack.pro');//插件：用来合并base.config和当前环境的configconst merge = require('webpack-merge');module.exports = (env) =&gt;&#123; const isDev = env.development;//是否是开发环境 const base = &#123; //TODO:公共配置 &#125; //根据环境选择不同的config配置，这里只配置了两种常用环境 return isDev ? merge(base,dev) : merge(base,prod);&#125; webpack-dev-serverwebpack-dev-server 用于本地开发环境下，可以热更新，而无需重复打包。它打包在内存当中，而不是磁盘中。默认访问项目的根目录。 安装 1yarn add webpack-dev-server --save-dev 配置脚本 12345\"scripts\":&#123; \"serve\": \"webpack-dev-server --env.development --config ./build/webpack.base.js\", \"build\": \"webpack --env.produciton --config ./build/webpack.base.js\"&#125; 配置config 12345678910111213/**webpack.dev.js*/const path = require('path');module.exports = &#123; mode:'development', devServer:&#123; port:8080, compress:true,//是否压缩 contentBase:path.resolve(__dirname,'../dist')//告诉服务器从哪个目录中提取内容 &#125;&#125; webpack基础配置1234567891011121314151617181920212223242526272829303132/**webpack.base.js*/const dev = require('./webpack.dev');const prod = require('./webpack.pro');const path = require('path');const merge = require('webpack-merge');module.exports = (env)=&gt;&#123; const isDev = env.development; const base = &#123; //配置入口指引webpack启动，路径需要绝对路径 entry:path.resolve(__dirname,'../src/index'),//单文件 /** *多文件打包 *entry:&#123; *home: './home.js', *about: './about.js', *contact: './contact.js' */ //配置打包的出口 output:&#123; filename: 'bundle.js', //filename:'[name].bundle.js', name值会根据多入口的name配置 //filename: '[name].[hash].bundle.js',has打包模式 path: path.resolve(__dirname, '../dist')//打包的出口 &#125; &#125;&#125;","categories":[{"name":"front-end","slug":"front-end","permalink":"https://cyh41.github.io/categories/front-end/"}],"tags":[{"name":"What's up webpack","slug":"What-s-up-webpack","permalink":"https://cyh41.github.io/tags/What-s-up-webpack/"}]},{"title":"vue-双向绑定与事件(下)","slug":"vue-双向绑定与事件(下)","date":"2019-09-21T03:06:10.000Z","updated":"2019-09-21T07:43:18.708Z","comments":true,"path":"2019/09/21/vue-双向绑定与事件(下)/","link":"","permalink":"https://cyh41.github.io/2019/09/21/vue-双向绑定与事件(下)/","excerpt":"","text":"非表单元素实现双向绑定dialog组件这里封装一个简易的 Dialog ，需要实现 父组件可以操作显示与否 2.Dialog组件可以自行隐藏 12345678910111213141516171819202122232425262728293031&lt;!--home.vue --&gt;&lt;template&gt;&lt;div class=\"container\"&gt;&lt;!--dialog组件 --&gt;&lt;el-dialog :visible=\"visible\" /&gt;&lt;button @click=\"switchVisible(!visible)\"&gt;切换弹窗显隐&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:'home', methods:&#123; switchVisible(visible=false)&#123; this.visible = visible &#125; &#125;, data()&#123; return&#123; visible:false &#125; &#125;&#125;&lt;/script&gt;&lt;!-- style部分略--&gt; 123456789101112131415161718192021222324252627&lt;!--el-dialog.vue --&gt;&lt;template&gt;&lt;div class=\"modal\" :style=\"&#123;display: visible ? 'block' : 'none'&#125;\"&gt; &lt;button @click=\"handleHide\"&gt;隐藏弹窗&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:'el-dialog', props:&#123; visible:Boolean &#125;, methods:&#123; /**隐藏弹窗*/ handleHide()&#123; //TODO:这里应该怎么写呢 &#125; &#125;&#125;&lt;/script&gt;&lt;!-- style部分略--&gt; 这么写可以实现 home组件内 可以切换 dialog组件的显隐。但是弹窗组件内部应该怎么去操作 visible 呢？ 或许你会想说这没做。 1234/**隐藏弹窗*/handleHide()&#123; this.visible = false;&#125; 但是在上篇 有说过，vue其实是单数据流。在官网prop的知识点当中也有说过避免子组件直接操作父组件传递的prop的值，这样会导致你的数据流向难于理解。比如说如果一个通用组件被一个组件所复用，那么值的改变会变得非常混乱。 参考上篇的 v-model 的组件通信用法，我们同样可以把该方法的原理用在非表单组件的通信上。 1234&lt;!--home.vue--&gt;&lt;!--dialog组件，在上面绑定prop与event --&gt;&lt;el-dialog :visible=\"visible\" @handleHide=\"switchVisible\" /&gt; 123456/** dialog.vue *//**隐藏弹窗*/handleHide()&#123; this.$emit('handleHide',false)&#125; $emit 方法在子父组件通信中非常常见。它的第一个参数值为 event 名，该event 必须在父组件调用子组件 template 的位置上有声明。该事件名我们可以称它为监听器，当触发该事件时，附加参数都会传给监听器回调。多参数传递类似 apply。 .sync修饰符为使 这个逻辑更容易理解，声明的事件更像 是个 监听器。我们可以用 update:myPropName 的模式去重写。 1234&lt;!--home.vue--&gt;&lt;!--dialog组件--&gt;&lt;el-dialog :visible=\"visible\" @update:visible=\"switchVisible\" /&gt; 123456/** dialog.vue *//**隐藏弹窗*/handleHide()&#123; this.$emit('update:visible',false)&#125; 这种写法我们无需关心事件的名称，只需要注意需要改变的值。监听器的名称我们可以都统一用 update。这样的写法更加专注。如果遇到多个属性需要同时监听的时候，这么写也会优雅很多。 在使用 表单时，v-model 把这些prop+event进行了封装。同样，非表单元素也提供了类似的方案，那就是.sync修饰符。 1234&lt;!--home.vue--&gt;&lt;!--dialog组件--&gt;&lt;el-dialog :visible.sync=\"visible\"/&gt; 当遇到多个一个对象中多个值需要监听的时候： 1234&lt;!--home.vue--&gt;&lt;!--dialog组件,object = &#123;name:'zhenyizhen',age:70,sex:'unknown'&#125;--&gt;&lt;el-dialog :visible.sync=\"object\"/&gt; $listeners回到我们前面说的 event。在上一篇的 自定义input组件当中。如果我们想直接通过父组件自定义input组件的方法，普通的写法会无效，需要添加.native ，同时input组件的根元素必须为input标签。 123456789101112131415161718&lt;!--home.vue --&gt;&lt;!-- 无效--&gt;&lt;el-input @focus=\"focus\"&gt;&lt;/el-input&gt;&lt;!-- 有效--&gt;&lt;el-input @focus.native=\"focus\"&gt;&lt;/el-input&gt;&lt;script&gt;export default &#123; name:'home', methods:&#123; focus()&#123; console.log(focus) &#125; &#125;&#125;&lt;/script&gt; 同 $attrs 接收组件传递的属性，vue也拥有个类似的属性，用来接收方法，叫 $listeners（2.4.0新增）。所有未添加 .native 修饰符的方法，都会被存储至此。该属性也可以在 beforeCreate 阶段访问。在上面的例子中，如果input组件的根元素不是input标签，就可以使用此方法。","categories":[{"name":"front-end","slug":"front-end","permalink":"https://cyh41.github.io/categories/front-end/"}],"tags":[{"name":"What's up Vue","slug":"What-s-up-Vue","permalink":"https://cyh41.github.io/tags/What-s-up-Vue/"},{"name":"component communication","slug":"component-communication","permalink":"https://cyh41.github.io/tags/component-communication/"}]},{"title":"vue-双向绑定与事件(上)","slug":"vue-双向绑定与事件(上)","date":"2019-09-17T09:47:58.000Z","updated":"2019-09-21T03:27:46.015Z","comments":true,"path":"2019/09/17/vue-双向绑定与事件(上)/","link":"","permalink":"https://cyh41.github.io/2019/09/17/vue-双向绑定与事件(上)/","excerpt":"","text":"Preface1.vue的双向绑定是什么❓2.v-model的原理是什么❓3.为什么v-model只适用于表单元素❓4.为何你这么捞❓ What’s the v-model 普通表单元素使用 v-model 12345678910111213141516171819202122232425262728&lt;!-- v-model.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;input v-model=\"text\"&gt; &lt;!-- 这里的值会跟input的值同步 --&gt; &lt;p&gt;&#123;&#123;text&#125;&#125;&lt;/p&gt; &lt;input type=\"checkbox\" v-model=\"checked\"&gt; &lt;!-- 这里的值会跟checkbox的值同步 --&gt; &lt;p&gt;&#123;&#123;checked&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"v-model\", data() &#123; return &#123; text: \"\", checked:false &#125;; &#125;&#125;;&lt;/script&gt; 等同于 123456789101112131415161718192021222324252627282930&lt;!-- v-model.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;input :value=\"text\" @input=\"this.text = $event.target.value\"&gt; &lt;!-- 这里的值会跟input输入的值同步 --&gt; &lt;p&gt;&#123;&#123;text&#125;&#125;&lt;/p&gt; &lt;input type=\"checkbox\" :checked=\"checked\" @change=\"checked = $event.target.checked\"&gt; &lt;!-- 这里的值会跟checkbox的值同步 --&gt; &lt;p&gt;&#123;&#123;checked&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"v-model\", data() &#123; return &#123; text: \"\", checked:false &#125;; &#125;&#125;;&lt;/script&gt; 简单来说 v-model就是 prop + event 的语法🍬。针对不同的表单类型，vue都会有一套不同的默认 mode 。 text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 这里 也很好的回答了前言的第3个问题。为什么v-model只适用于表单元素? 因为只有表单元素会有默认的event和标准属性。不过其它元素本身就有一些不错的类似于 v-model的方案。 组件使用 v-model 1234567891011121314151617&lt;!--el-input.vue --&gt;&lt;template&gt; &lt;input :value=\"value\" @input=\"$emit('input',$event.target.value)\" /&gt; &lt;/template&gt;&lt;script&gt;export default &#123; name:'el-input', //这里其实默认配置了model // model: &#123; // props: \"value\", // event: \"input\" // &#125;, props:['value']&#125;&lt;/script&gt; 1234567891011121314151617181920&lt;!--el-checkbox.vue --&gt;&lt;template&gt; &lt;input type=\"checkbox\" :checked=\"checked\" @change=\"$emit('change',$event.target.checked)\" /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:'el-checkbox', //这里需要手动声明model model: &#123; props: \"checked\", event: \"change\" &#125;, props:['checked']&#125;&lt;/script&gt; 123456789101112131415161718192021222324252627&lt;!--box.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;el-input v-model=\"value\" /&gt; &lt;!--等同于 &lt;el-input :value=\"value\" @input=\"value=$event.target.value\"/&gt;--&gt; &lt;el-checkbox v-model=\"checked\"&gt;&lt;/el-checkbox&gt; &lt;!--等同于 &lt;el-input :checked=\"checked\" @change=\"value=$event.target.checked\"/&gt;--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:'box', data()&#123; return &#123; //el-input绑定的值 value:'', //el-checkbox绑定的值 checked:false &#125;&#125;&#125;&lt;/script&gt; 通过上面的🌰，其实可以很直观的看到，v-model 所谓的双向绑定，同样也只是个语法🍬而已，单向绑定value + 事件侦听。其实操作的都只是同一个value。 在使用 v-model 进行上面操作的时候有几个地方需要注意⚠️： v-model 仅仅适用于表单元素 12345678910111213141516&lt;!--el-input.vue --&gt; &lt;template&gt; &lt;!--v-model被传递到了根元素div上，此时input的操作都无效了 --&gt; &lt;div&gt; &lt;input :value=\"value\" @input=\"$emit('input',$event.target.value)\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;!--box.vue--&gt;&lt;template&gt; &lt;div&gt; &lt;!--这里会把v-model传递到el-input的根元素上 --&gt; &lt;el-input v-model=\"value\"&gt;&lt;/el-input&gt; &lt;/div&gt;&lt;/template&gt; 子组件中不能使用 v-model 绑定父组件传递的prop的值 123456789101112&lt;!--el-input.vue --&gt; &lt;template&gt; &lt;!--这里没有使用语法糖v-model &lt;input :value=\"value\" @input=\"$emit('input',$event.target.value)\" /&gt;--&gt; &lt;!--如果使用v-model --&gt; &lt;input v-model=\"value\"/&gt; &lt;!--等同于 &lt;input :value=\"value\" @input=\"value=$event.target.value\" /&gt;--&gt;&lt;/template&gt; 如果这么写会直接⚠️ 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 conclusion v-model 的本质并不是双向绑定，而是单项数据流，所操作的数据还是prop传入前的数据源。 v-model 只适用于表单元素。因为 它 触发的 $event 只能访问到标签的标准属性，也就是说你只能对标准属性进行操作（如 value，checked），这里可以参考 v-model 相关源码。 v-model 原理就是 prop + event。","categories":[{"name":"front-end","slug":"front-end","permalink":"https://cyh41.github.io/categories/front-end/"}],"tags":[{"name":"What's up Vue","slug":"What-s-up-Vue","permalink":"https://cyh41.github.io/tags/What-s-up-Vue/"},{"name":"component communication","slug":"component-communication","permalink":"https://cyh41.github.io/tags/component-communication/"}]},{"title":"vue-$attrs","slug":"vue-$attrs","date":"2019-08-23T08:24:06.000Z","updated":"2019-09-20T07:33:34.856Z","comments":true,"path":"2019/08/23/vue-$attrs/","link":"","permalink":"https://cyh41.github.io/2019/08/23/vue-$attrs/","excerpt":"","text":"Preface在我们日常通信中，prop，基本可以满足业务场景中父子通信的情况。但在高级组件中，比如自己写的通用组件，二次封装element等UI框架等场景，attrs和listeners就大有作为了。 Basics Code 1234567&lt;!-- China.vue --&gt;&lt;template&gt; &lt;div class=\"China\"&gt; &lt;HongKong where=\"China\" :money=\"100\"/&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718&lt;!-- HongKong.vue --&gt;&lt;template&gt; &lt;div class=\"HongKong\"&gt; &lt;p&gt; Hongkong is part of &#123;&#123;where&#125;&#125; &lt;/p&gt; &lt;p&gt; show me the money:&#123;&#123;money&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"HongKong\", props: [\"where\"]&#125;;&lt;/script&gt; devTools Rendering 图中 Mustache语法money未在实例中找到该属性的声明，会报Property or method &quot;money&quot; is not defined on the instance but referenced during render错误。请确定声明后再使用。 可以看到，父组件 传递的属性未在 子组件props中声明，则会默认挂载至子组件根元素上。 这是因为：未在子组件props中声明的属性，会被作为普通的HTML特性应用在子组件的根元素上。可以通过配置子组件inheritAttrs:false（2.4.0 新增）将默认行为去掉（即，在根元素中不会挂载继承属性）。但无论是否配置inheritAttrs，都可以通实例属性$attrs（2.4.0 新增）获取到。 该属性不影响class和style。 1234//HongKongcreated()&#123; console.log(this.$attrs)//&#123;money:100&#125;&#125; Scene当我们自行封装一个简易的input组件，在使用过程中，可能传入不同的多个原生属性。 传统props写法： 1234567891011121314151617181920212223242526272829&lt;!-- box.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;label :for=\"name\"&gt;&#123;&#123;label&#125;&#125;&lt;/label&gt; &lt;el-input :type=\"type\" :value=\"value\" :name=\"name\" :placeholder=\"placeholder\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ElInput from \"@/components/input.vue\";export default &#123; components: &#123; ElInput &#125;, data() &#123; return &#123; label: \"姓名\", //要传入组件的属性 name: \"name\", type: \"text\", value: \"妮可基德曼\", placeholder: \"请输入姓名\" &#125;; &#125;&#125;;&lt;/script&gt; 1234567891011121314151617181920212223&lt;template&gt; &lt;div clas=\"el-input\"&gt; &lt;input class=\"input\" :type=\"type\" :value=\"value\" :name=\"name\" :placeholder=\"placeholder\" @input=\"handleInput\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ElInput\", props: [\"name\", \"type\", \"value\", \"placeholder\"], methods: &#123; handleInput(event) &#123; this.$emit(\"input\", event.target.value); &#125; &#125;&#125;;&lt;/script&gt; $attrs方法 123456789101112131415161718192021222324252627282930&lt;!-- box.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;label :for=\"inputConfig.name\"&gt;&#123;&#123;label&#125;&#125;&lt;/label&gt; &lt;el-input v-bind=\"inputConfig\" v-model=\"value\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ElInput from \"@/components/input.vue\";export default &#123; components: &#123; ElInput &#125;, data() &#123; return &#123; label: \"姓名\", value: \"nas\", inputConfig: &#123; //要传入组件的属性 name: \"name\", type: \"text\", placeholder: \"请输入姓名\" &#125; &#125;; &#125;&#125;;&lt;/script&gt; 123456789101112131415161718192021&lt;!-- input.vue --&gt;&lt;template&gt; &lt;div clas=\"el-input\"&gt; &lt;input class=\"input\" v-bind=\"$attrs\" @input=\"handleInput\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ElInput\", inheritAttrs: false,//不加这条规则，$attrs会默认挂载到根元素上 methods: &#123; handleInput(event) &#123; this.$emit(\"input\", event.target.value); &#125; &#125;&#125;;&lt;/script&gt; 很明显的，$attrs减少了不少的代码量，整体看起来确实优雅很多，虽说$attrs可以代替props，但$attrs更适合原生属性或不需要处理的属性。 在很多场景下，比如要对属性进行校验、默认值、处理等操作，更建议使用props。每个属性都有它存在的意义，合理的运用不同属性应对不同的场景，才能发挥其最大作用。 Others Lifecycle $attrs可访问的阶段是 beforeCreate，而props访问阶段为created。 Render Function &amp; JSX 12345678910111213141516//input.jsexport default &#123; name: 'ElInput', inheritAttrs: false, render(h) &#123; //TODO:这里放jsx或render function &#125;, methods: &#123; handleInput(event) &#123; this.$emit('input', event.target.value); &#125;, &#125;,&#125;; 123456789101112131415//render写法 render(h) &#123; return h('div', &#123; class: 'el-input', &#125;, [ h('input', &#123; //绑定在attrs上 attrs: this.$attrs, on: &#123; input: this.handleInput, &#125;, &#125;), ]); &#125;, 123456//jsx写法 render(h) &#123; return &lt;div class=\"el-input\"&gt; &lt;input attrs=&#123;this.$attrs&#125; on-input=&#123;this.handleInput&#125; /&gt; &lt;/div&gt;; &#125;, 若 v-bind=“$attrs” 中的某个属性 已经有声明，则原生属性的优先级更高。 12&lt;!-- $attrs为&#123;type:\"text\"&#125;，最后生效的为type=\"number\" --&gt;&lt;input type=\"number\" v-bind=\"$attrs\"/&gt;","categories":[{"name":"front-end","slug":"front-end","permalink":"https://cyh41.github.io/categories/front-end/"}],"tags":[{"name":"What's up Vue","slug":"What-s-up-Vue","permalink":"https://cyh41.github.io/tags/What-s-up-Vue/"},{"name":"component communication","slug":"component-communication","permalink":"https://cyh41.github.io/tags/component-communication/"}]}]}